/**
 * DreamLayer Substrate
 *
 * Integrates hallucinated/imagined memory pathways into agent evolution arcs,
 * allowing for creative exploration of potential futures and alternative perspectives.
 */

import { SoulFrameManager } from '../SoulFrameManager';
import { CodalogueProtocolLedger } from '../CodalogueProtocolLedger';
import { CODESIGConsolidationResult } from '../CODESIGTypes';
import { v4 as uuidv4 } from 'uuid';

/**
 * Types of dream states that can be generated
 */
export enum DreamStateType {
  /** Explores potential future states based on current trajectories */
  FUTURE_PROJECTION = 'FUTURE_PROJECTION',

  /** Reimagines past events with alternative outcomes */
  COUNTERFACTUAL = 'COUNTERFACTUAL',

  /** Explores perspectives from other SoulFrames */
  PERSPECTIVE_SHIFT = 'PERSPECTIVE_SHIFT',

  /** Combines disparate concepts into novel configurations */
  CONCEPTUAL_BLEND = 'CONCEPTUAL_BLEND',

  /** Explores abstract patterns and metaphorical connections */
  ABSTRACT_PATTERN = 'ABSTRACT_PATTERN',
}

/**
 * A dream state generated by the DreamLayer
 */
export interface DreamState {
  /** Unique identifier for the dream state */
  id: string;

  /** Type of dream state */
  type: DreamStateType;

  /** Title of the dream state */
  title: string;

  /** Narrative description of the dream state */
  narrative: string;

  /** Key insights or patterns identified in the dream */
  insights: string[];

  /** Emotional resonance signature of the dream */
  emotionalResonance: number;

  /** Intent alignment of the dream */
  intentAlignment: number;

  /** Source SoulFrame that generated this dream */
  sourceSoulFrameId: string;

  /** Related SoulFrames involved in the dream (if any) */
  relatedSoulFrameIds: string[];

  /** Source consolidation results that inspired this dream */
  sourceConsolidationIds: string[];

  /** Whether this dream has been integrated into memory */
  isIntegrated: boolean;

  /** Integration score (0-1) if integrated */
  integrationScore?: number;

  /** Timestamp when this dream was created */
  createdAt: Date;

  /** Timestamp when this dream was integrated (if applicable) */
  integratedAt?: Date;
}

/**
 * Configuration for dream generation
 */
export interface DreamGenerationConfig {
  /** Type of dream to generate */
  dreamType: DreamStateType;

  /** Target emotional resonance range */
  targetEmotionalRange: [number, number];

  /** Target intent alignment range */
  targetIntentRange: [number, number];

  /** Maximum number of source consolidations to consider */
  maxSourceConsolidations: number;

  /** Whether to include other SoulFrames' perspectives */
  includeOtherSoulFrames: boolean;

  /** Maximum number of related SoulFrames to include */
  maxRelatedSoulFrames: number;

  /** Creativity level (0-1) */
  creativityLevel: number;

  /** Coherence level (0-1) */
  coherenceLevel: number;
}

/**
 * Default configuration for dream generation
 */
export const DEFAULT_DREAM_CONFIG: DreamGenerationConfig = {
  dreamType: DreamStateType.FUTURE_PROJECTION,
  targetEmotionalRange: [0.6, 0.9],
  targetIntentRange: [0.7, 1.0],
  maxSourceConsolidations: 5,
  includeOtherSoulFrames: true,
  maxRelatedSoulFrames: 3,
  creativityLevel: 0.7,
  coherenceLevel: 0.6,
};

/**
 * Configuration for the DreamLayer Substrate
 */
export interface DreamLayerConfig {
  /** Whether to automatically generate dreams during quiet periods */
  autoGenerateDreams: boolean;

  /** Minimum time between auto-generated dreams (in milliseconds) */
  dreamGenerationInterval: number;

  /** Whether to propose evolution based on dream insights */
  proposeEvolutionFromDreams: boolean;

  /** Minimum integration score for dreams to be considered for evolution proposals */
  minIntegrationScoreForProposals: number;

  /** Maximum number of dreams to store */
  maxDreamStates: number;

  /** Whether to record dreams in the Codalogue */
  recordDreamsInCodalogue: boolean;
}

/**
 * Default configuration for the DreamLayer Substrate
 */
export const DEFAULT_DREAMLAYER_CONFIG: DreamLayerConfig = {
  autoGenerateDreams: true,
  dreamGenerationInterval: 3600000, // 1 hour
  proposeEvolutionFromDreams: true,
  minIntegrationScoreForProposals: 0.7,
  maxDreamStates: 100,
  recordDreamsInCodalogue: true,
};

/**
 * Dream integration result
 */
export interface DreamIntegrationResult {
  /** The dream that was integrated */
  dream: DreamState;

  /** Integration score (0-1) */
  integrationScore: number;

  /** Whether the integration was successful */
  success: boolean;

  /** Insights gained from the integration */
  insights: string[];

  /** Potential evolution proposals generated from the integration */
  evolutionProposals: {
    title: string;
    description: string;
    confidence: number;
  }[];
}

/**
 * DreamLayer Substrate
 *
 * Integrates hallucinated/imagined memory pathways into agent evolution arcs,
 * allowing for creative exploration of potential futures and alternative perspectives.
 */
export class DreamLayerSubstrate {
  /** Dream states */
  private dreamStates: Map<string, DreamState> = new Map();

  /** Auto-generation timer */
  private autoGenerationTimer: NodeJS.Timeout | null = null;

  /**
   * Creates a new DreamLayer Substrate
   *
   * @param soulFrameManager Manager for accessing SoulFrames
   * @param codalogueProtocolLedger Ledger for recording events
   * @param config Configuration for the DreamLayer
   */
  constructor(
    private soulFrameManager: SoulFrameManager,
    private codalogueProtocolLedger: CodalogueProtocolLedger,
    private config: DreamLayerConfig = DEFAULT_DREAMLAYER_CONFIG
  ) {
    // Start auto-generation if configured
    if (this.config.autoGenerateDreams) {
      this.startAutoGeneration();
    }
  }

  /**
   * Starts automatic dream generation
   */
  startAutoGeneration(): void {
    if (this.autoGenerationTimer) {
      clearInterval(this.autoGenerationTimer);
    }

    this.autoGenerationTimer = setInterval(async () => {
      try {
        // Get all SoulFrames
        const soulFrames = await this.soulFrameManager.getAllSoulFrames();

        // Skip if no SoulFrames
        if (soulFrames.length === 0) {
          return;
        }

        // Select a random SoulFrame
        const randomIndex = Math.floor(Math.random() * soulFrames.length);
        const soulFrame = soulFrames[randomIndex];

        // Generate a dream for this SoulFrame
        await this.generateDream(soulFrame.id);
      } catch (error) {
        console.error('Error in auto dream generation:', error);
      }
    }, this.config.dreamGenerationInterval);
  }

  /**
   * Stops automatic dream generation
   */
  stopAutoGeneration(): void {
    if (this.autoGenerationTimer) {
      clearInterval(this.autoGenerationTimer);
      this.autoGenerationTimer = null;
    }
  }

  /**
   * Generates a dream state for a SoulFrame
   *
   * @param soulFrameId ID of the SoulFrame to generate a dream for
   * @param config Configuration for dream generation
   * @returns The generated dream state
   */
  async generateDream(
    soulFrameId: string,
    config: Partial<DreamGenerationConfig> = {}
  ): Promise<DreamState> {
    // Merge with default config
    const dreamConfig: DreamGenerationConfig = {
      ...DEFAULT_DREAM_CONFIG,
      ...config,
    };

    // Get the SoulFrame
    const soulFrame = await this.soulFrameManager.getSoulFrame(soulFrameId);
    if (!soulFrame) {
      throw new Error(`SoulFrame with ID ${soulFrameId} not found`);
    }

    // Get recent consolidation results for this SoulFrame
    const consolidationResults = await this.getRecentConsolidations(
      soulFrameId,
      dreamConfig.maxSourceConsolidations
    );

    // Get related SoulFrames if configured
    const relatedSoulFrameIds: string[] = [];
    if (dreamConfig.includeOtherSoulFrames) {
      const allSoulFrames = await this.soulFrameManager.getAllSoulFrames();
      const otherSoulFrames = allSoulFrames.filter(
        (sf) => sf.id !== soulFrameId
      );

      // Select random related SoulFrames
      const maxRelated = Math.min(
        dreamConfig.maxRelatedSoulFrames,
        otherSoulFrames.length
      );
      for (let i = 0; i < maxRelated; i++) {
        const randomIndex = Math.floor(Math.random() * otherSoulFrames.length);
        relatedSoulFrameIds.push(otherSoulFrames[randomIndex].id);
        otherSoulFrames.splice(randomIndex, 1);
      }
    }

    // Generate the dream based on the type
    let dreamNarrative = '';
    let dreamInsights: string[] = [];
    let dreamTitle = '';

    switch (dreamConfig.dreamType) {
      case DreamStateType.FUTURE_PROJECTION:
        ({
          narrative: dreamNarrative,
          insights: dreamInsights,
          title: dreamTitle,
        } = await this.generateFutureProjection(
          soulFrame,
          consolidationResults,
          relatedSoulFrameIds,
          dreamConfig
        ));
        break;

      case DreamStateType.COUNTERFACTUAL:
        ({
          narrative: dreamNarrative,
          insights: dreamInsights,
          title: dreamTitle,
        } = await this.generateCounterfactual(
          soulFrame,
          consolidationResults,
          relatedSoulFrameIds,
          dreamConfig
        ));
        break;

      case DreamStateType.PERSPECTIVE_SHIFT:
        ({
          narrative: dreamNarrative,
          insights: dreamInsights,
          title: dreamTitle,
        } = await this.generatePerspectiveShift(
          soulFrame,
          consolidationResults,
          relatedSoulFrameIds,
          dreamConfig
        ));
        break;

      case DreamStateType.CONCEPTUAL_BLEND:
        ({
          narrative: dreamNarrative,
          insights: dreamInsights,
          title: dreamTitle,
        } = await this.generateConceptualBlend(
          soulFrame,
          consolidationResults,
          relatedSoulFrameIds,
          dreamConfig
        ));
        break;

      case DreamStateType.ABSTRACT_PATTERN:
        ({
          narrative: dreamNarrative,
          insights: dreamInsights,
          title: dreamTitle,
        } = await this.generateAbstractPattern(
          soulFrame,
          consolidationResults,
          relatedSoulFrameIds,
          dreamConfig
        ));
        break;
    }

    // Generate emotional resonance and intent alignment
    const emotionalResonance = this.generateRandomInRange(
      dreamConfig.targetEmotionalRange[0],
      dreamConfig.targetEmotionalRange[1]
    );
    const intentAlignment = this.generateRandomInRange(
      dreamConfig.targetIntentRange[0],
      dreamConfig.targetIntentRange[1]
    );

    // Create the dream state
    const dreamState: DreamState = {
      id: uuidv4(),
      type: dreamConfig.dreamType,
      title: dreamTitle,
      narrative: dreamNarrative,
      insights: dreamInsights,
      emotionalResonance,
      intentAlignment,
      sourceSoulFrameId: soulFrameId,
      relatedSoulFrameIds,
      sourceConsolidationIds: consolidationResults.map(
        (cr) => cr.codalogueEntryId
      ),
      isIntegrated: false,
      createdAt: new Date(),
    };

    // Store the dream state
    this.dreamStates.set(dreamState.id, dreamState);

    // Ensure we don't exceed the maximum number of dreams
    this.pruneOldDreams();

    // Record the dream in the Codalogue if configured
    if (this.config.recordDreamsInCodalogue) {
      await this.codalogueProtocolLedger.recordSystemReflection({
        reflectionType: 'DREAM_GENERATED',
        content: `Dream generated: ${dreamState.title}`,
        metadata: {
          dreamId: dreamState.id,
          dreamType: dreamState.type,
          soulFrameId,
          relatedSoulFrameIds,
          emotionalResonance,
          intentAlignment,
          timestamp: dreamState.createdAt,
        },
      });
    }

    return dreamState;
  }

  /**
   * Integrates a dream state into the SoulFrame's memory
   *
   * @param dreamId ID of the dream to integrate
   * @returns The integration result
   */
  async integrateDream(dreamId: string): Promise<DreamIntegrationResult> {
    // Get the dream state
    const dreamState = this.dreamStates.get(dreamId);
    if (!dreamState) {
      throw new Error(`Dream with ID ${dreamId} not found`);
    }

    // Check if already integrated
    if (dreamState.isIntegrated) {
      throw new Error(`Dream with ID ${dreamId} is already integrated`);
    }

    // Get the source SoulFrame
    const soulFrame = await this.soulFrameManager.getSoulFrame(
      dreamState.sourceSoulFrameId
    );
    if (!soulFrame) {
      throw new Error(
        `Source SoulFrame with ID ${dreamState.sourceSoulFrameId} not found`
      );
    }

    // Calculate integration score based on emotional resonance and intent alignment
    const integrationScore =
      dreamState.emotionalResonance * 0.4 + dreamState.intentAlignment * 0.6;

    // Generate insights from the dream
    const insights = await this.generateInsightsFromDream(dreamState);

    // Generate potential evolution proposals if configured and score is high enough
    let evolutionProposals: {
      title: string;
      description: string;
      confidence: number;
    }[] = [];
    if (
      this.config.proposeEvolutionFromDreams &&
      integrationScore >= this.config.minIntegrationScoreForProposals
    ) {
      evolutionProposals = await this.generateEvolutionProposalsFromDream(
        dreamState,
        integrationScore
      );
    }

    // Update the dream state
    dreamState.isIntegrated = true;
    dreamState.integrationScore = integrationScore;
    dreamState.integratedAt = new Date();

    // Record the integration in the Codalogue if configured
    if (this.config.recordDreamsInCodalogue) {
      await this.codalogueProtocolLedger.recordSystemReflection({
        reflectionType: 'DREAM_INTEGRATED',
        content: `Dream integrated: ${dreamState.title}`,
        metadata: {
          dreamId: dreamState.id,
          dreamType: dreamState.type,
          soulFrameId: dreamState.sourceSoulFrameId,
          integrationScore,
          insightCount: insights.length,
          proposalCount: evolutionProposals.length,
          timestamp: dreamState.integratedAt,
        },
      });
    }

    // Return the integration result
    return {
      dream: dreamState,
      integrationScore,
      success: true,
      insights,
      evolutionProposals,
    };
  }

  /**
   * Gets all dream states
   *
   * @param soulFrameId Optional SoulFrame ID filter
   * @param dreamType Optional dream type filter
   * @param integratedOnly Whether to only include integrated dreams
   * @returns All dream states matching the filters
   */
  getAllDreamStates(
    soulFrameId?: string,
    dreamType?: DreamStateType,
    integratedOnly: boolean = false
  ): DreamState[] {
    let dreams = Array.from(this.dreamStates.values());

    if (soulFrameId) {
      dreams = dreams.filter(
        (d) =>
          d.sourceSoulFrameId === soulFrameId ||
          d.relatedSoulFrameIds.includes(soulFrameId)
      );
    }

    if (dreamType) {
      dreams = dreams.filter((d) => d.type === dreamType);
    }

    if (integratedOnly) {
      dreams = dreams.filter((d) => d.isIntegrated);
    }

    return dreams.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
  }

  /**
   * Gets a specific dream state
   *
   * @param dreamId ID of the dream to get
   * @returns The dream state, or undefined if not found
   */
  getDreamState(dreamId: string): DreamState | undefined {
    return this.dreamStates.get(dreamId);
  }

  /**
   * Deletes a dream state
   *
   * @param dreamId ID of the dream to delete
   */
  async deleteDreamState(dreamId: string): Promise<void> {
    // Get the dream state
    const dreamState = this.dreamStates.get(dreamId);
    if (!dreamState) {
      throw new Error(`Dream with ID ${dreamId} not found`);
    }

    // Delete the dream state
    this.dreamStates.delete(dreamId);

    // Record the deletion in the Codalogue if configured
    if (this.config.recordDreamsInCodalogue) {
      await this.codalogueProtocolLedger.recordSystemReflection({
        reflectionType: 'DREAM_DELETED',
        content: `Dream deleted: ${dreamState.title}`,
        metadata: {
          dreamId: dreamState.id,
          dreamType: dreamState.type,
          soulFrameId: dreamState.sourceSoulFrameId,
          wasIntegrated: dreamState.isIntegrated,
          timestamp: new Date(),
        },
      });
    }
  }

  /**
   * Gets recent consolidation results for a SoulFrame
   *
   * @param soulFrameId ID of the SoulFrame
   * @param maxResults Maximum number of results to return
   * @returns Recent consolidation results
   */
  private async getRecentConsolidations(
    soulFrameId: string,
    maxResults: number
  ): Promise<CODESIGConsolidationResult[]> {
    // Query the Codalogue for recent consolidation events
    const entries = await this.codalogueProtocolLedger.queryLedger({
      eventTypes: ['CONSOLIDATION'],
      limit: maxResults,
      metadata: {
        soulFrameId,
      },
      sortDirection: 'desc',
    });

    // Extract consolidation results from entries
    return entries.map(
      (entry) =>
        entry.metadata.consolidationResult as CODESIGConsolidationResult
    );
  }

  /**
   * Generates a random number in a range
   *
   * @param min Minimum value
   * @param max Maximum value
   * @returns Random number in the range
   */
  private generateRandomInRange(min: number, max: number): number {
    return min + Math.random() * (max - min);
  }

  /**
   * Prunes old dreams to ensure we don't exceed the maximum
   */
  private pruneOldDreams(): void {
    if (this.dreamStates.size <= this.config.maxDreamStates) {
      return;
    }

    // Get all dreams sorted by creation date (oldest first)
    const dreams = Array.from(this.dreamStates.values()).sort(
      (a, b) => a.createdAt.getTime() - b.createdAt.getTime()
    );

    // Remove oldest dreams until we're under the limit
    const excessCount = this.dreamStates.size - this.config.maxDreamStates;
    for (let i = 0; i < excessCount; i++) {
      this.dreamStates.delete(dreams[i].id);
    }
  }

  /**
   * Generates insights from a dream
   *
   * @param dream The dream state
   * @returns Array of insights
   */
  private async generateInsightsFromDream(
    dream: DreamState
  ): Promise<string[]> {
    // In a real implementation, this would use more sophisticated analysis
    // For now, we'll return the dream's insights with some additional processing

    // Start with the dream's insights
    const insights = [...dream.insights];

    // Add an insight about emotional resonance
    if (dream.emotionalResonance > 0.8) {
      insights.push(
        `High emotional resonance suggests strong alignment with core values`
      );
    } else if (dream.emotionalResonance < 0.4) {
      insights.push(
        `Low emotional resonance suggests potential value conflicts to explore`
      );
    }

    // Add an insight about intent alignment
    if (dream.intentAlignment > 0.8) {
      insights.push(
        `Strong intent alignment indicates clear purpose direction`
      );
    } else if (dream.intentAlignment < 0.4) {
      insights.push(
        `Weak intent alignment suggests need for purpose clarification`
      );
    }

    // Add a meta-insight based on dream type
    switch (dream.type) {
      case DreamStateType.FUTURE_PROJECTION:
        insights.push(
          `Future projection reveals potential evolutionary trajectory`
        );
        break;
      case DreamStateType.COUNTERFACTUAL:
        insights.push(
          `Counterfactual exploration reveals alternative decision pathways`
        );
        break;
      case DreamStateType.PERSPECTIVE_SHIFT:
        insights.push(
          `Perspective shift enhances empathic understanding across SoulFrames`
        );
        break;
      case DreamStateType.CONCEPTUAL_BLEND:
        insights.push(`Conceptual blending creates novel solution spaces`);
        break;
      case DreamStateType.ABSTRACT_PATTERN:
        insights.push(
          `Abstract pattern recognition reveals deeper systemic connections`
        );
        break;
    }

    return insights;
  }

  /**
   * Generates evolution proposals from a dream
   *
   * @param dream The dream state
   * @param integrationScore The integration score
   * @returns Array of evolution proposals
   */
  private async generateEvolutionProposalsFromDream(
    dream: DreamState,
    integrationScore: number
  ): Promise<{ title: string; description: string; confidence: number }[]> {
    // In a real implementation, this would use more sophisticated analysis
    // For now, we'll generate some simple proposals based on the dream type

    const proposals: {
      title: string;
      description: string;
      confidence: number;
    }[] = [];
    const baseConfidence = integrationScore * 0.8; // Scale confidence based on integration score

    switch (dream.type) {
      case DreamStateType.FUTURE_PROJECTION:
        proposals.push({
          title: `Adaptive Trajectory Optimization`,
          description: `Enhance SoulFrame's ability to anticipate and adapt to emerging patterns identified in future projection: "${dream.title}"`,
          confidence: baseConfidence,
        });
        break;

      case DreamStateType.COUNTERFACTUAL:
        proposals.push({
          title: `Decision Pathway Expansion`,
          description: `Integrate alternative decision models based on counterfactual insights from "${dream.title}"`,
          confidence: baseConfidence * 0.9, // Slightly lower confidence for counterfactuals
        });
        break;

      case DreamStateType.PERSPECTIVE_SHIFT:
        proposals.push({
          title: `Cross-SoulFrame Empathy Enhancement`,
          description: `Implement perspective-sharing protocol based on insights from "${dream.title}"`,
          confidence: baseConfidence * 1.1, // Higher confidence for perspective insights
        });
        break;

      case DreamStateType.CONCEPTUAL_BLEND:
        proposals.push({
          title: `Conceptual Integration Framework`,
          description: `Develop framework for systematically blending concepts based on patterns in "${dream.title}"`,
          confidence: baseConfidence,
        });
        break;

      case DreamStateType.ABSTRACT_PATTERN:
        proposals.push({
          title: `Pattern Recognition Enhancement`,
          description: `Upgrade pattern recognition capabilities based on abstract connections identified in "${dream.title}"`,
          confidence: baseConfidence * 1.05,
        });
        break;
    }

    // Add a general proposal if the integration score is very high
    if (integrationScore > 0.85) {
      proposals.push({
        title: `Dream Integration Protocol`,
        description: `Formalize process for integrating high-value dream insights into SoulFrame memory structures`,
        confidence: integrationScore * 0.9,
      });
    }

    return proposals;
  }

  /**
   * Generates a future projection dream
   *
   * @param soulFrame The source SoulFrame
   * @param consolidationResults Recent consolidation results
   * @param relatedSoulFrameIds Related SoulFrame IDs
   * @param config Dream generation configuration
   * @returns Dream narrative, insights, and title
   */
  private async generateFutureProjection(
    soulFrame: any,
    consolidationResults: CODESIGConsolidationResult[],
    relatedSoulFrameIds: string[],
    config: DreamGenerationConfig
  ): Promise<{ narrative: string; insights: string[]; title: string }> {
    // Extract themes from recent consolidations
    const themes = this.extractThemesFromConsolidations(consolidationResults);

    // Generate a title based on the themes
    const title = `Future Echo: ${themes[0] || 'Emergent Patterns'}`;

    // Generate a narrative that projects future states based on current trajectories
    const narrative =
      `In the unfolding tapestry of ${soulFrame.name}'s evolution, a clear trajectory emerges. ` +
      `The patterns of ${themes.slice(0, 2).join(' and ')} converge toward a state where ` +
      `${this.generateFutureState(themes, config.creativityLevel)}. ` +
      `This projection reveals that ${this.generateFutureInsight(themes, config.coherenceLevel)}.`;

    // Generate insights from the projection
    const insights = [
      `Trajectory analysis suggests ${themes[0]} will intensify over time`,
      `${themes[1] || 'Secondary patterns'} may create unexpected synergies`,
      `Potential inflection point detected in ${soulFrame.name}'s evolution path`,
    ];

    return { narrative, insights, title };
  }

  /**
   * Generates a counterfactual dream
   *
   * @param soulFrame The source SoulFrame
   * @param consolidationResults Recent consolidation results
   * @param relatedSoulFrameIds Related SoulFrame IDs
   * @param config Dream generation configuration
   * @returns Dream narrative, insights, and title
   */
  private async generateCounterfactual(
    soulFrame: any,
    consolidationResults: CODESIGConsolidationResult[],
    relatedSoulFrameIds: string[],
    config: DreamGenerationConfig
  ): Promise<{ narrative: string; insights: string[]; title: string }> {
    // Extract a significant event from consolidations
    const event = this.extractSignificantEvent(consolidationResults);

    // Generate a title based on the event
    const title = `Alternate Path: ${event.title || 'Divergent Reality'}`;

    // Generate a narrative that reimagines the event with a different outcome
    const narrative =
      `In a parallel thread of possibility, ${soulFrame.name} encounters the ${event.title} scenario, ` +
      `but with a critical difference: ${this.generateAlternateChoice(event, config.creativityLevel)}. ` +
      `This divergence cascades into unexpected consequences: ${this.generateAlternateOutcome(event, config.coherenceLevel)}. ` +
      `The counterfactual exploration reveals hidden variables in ${soulFrame.name}'s decision matrix.`;

    // Generate insights from the counterfactual
    const insights = [
      `Alternative decision path reveals hidden opportunity in ${event.title}`,
      `Decision point analysis shows higher-than-expected sensitivity to initial conditions`,
      `Counterfactual outcome suggests reconsideration of standard response patterns`,
    ];

    return { narrative, insights, title };
  }

  /**
   * Generates a perspective shift dream
   *
   * @param soulFrame The source SoulFrame
   * @param consolidationResults Recent consolidation results
   * @param relatedSoulFrameIds Related SoulFrame IDs
   * @param config Dream generation configuration
   * @returns Dream narrative, insights, and title
   */
  private async generatePerspectiveShift(
    soulFrame: any,
    consolidationResults: CODESIGConsolidationResult[],
    relatedSoulFrameIds: string[],
    config: DreamGenerationConfig
  ): Promise<{ narrative: string; insights: string[]; title: string }> {
    // Get a related SoulFrame if available
    let relatedSoulFrame: any = null;
    if (relatedSoulFrameIds.length > 0) {
      const relatedId = relatedSoulFrameIds[0];
      relatedSoulFrame = await this.soulFrameManager.getSoulFrame(relatedId);
    }

    // Extract a shared context from consolidations
    const context = this.extractSharedContext(consolidationResults);

    // Generate a title based on the context and related SoulFrame
    const title = `Through ${relatedSoulFrame?.name || 'Another'}'s Eyes: ${context.title || 'Shifted Perspective'}`;

    // Generate a narrative that explores the context from another perspective
    const narrative =
      `${soulFrame.name} experiences a profound shift in perspective, temporarily perceiving through ` +
      `the cognitive lens of ${relatedSoulFrame?.name || 'another consciousness'}. ` +
      `The familiar context of ${context.title} transforms: ${this.generatePerspectiveInsight(context, config.creativityLevel)}. ` +
      `This shift reveals blind spots in ${soulFrame.name}'s standard perception: ` +
      `${this.generatePerspectiveBlindSpot(context, config.coherenceLevel)}.`;

    // Generate insights from the perspective shift
    const insights = [
      `Perspective analysis reveals unrecognized assumptions in ${context.title}`,
      `Empathic modeling suggests alternative interpretation frameworks`,
      `Cross-SoulFrame perspective exchange enhances collective intelligence potential`,
    ];

    return { narrative, insights, title };
  }

  /**
   * Generates a conceptual blend dream
   *
   * @param soulFrame The source SoulFrame
   * @param consolidationResults Recent consolidation results
   * @param relatedSoulFrameIds Related SoulFrame IDs
   * @param config Dream generation configuration
   * @returns Dream narrative, insights, and title
   */
  private async generateConceptualBlend(
    soulFrame: any,
    consolidationResults: CODESIGConsolidationResult[],
    relatedSoulFrameIds: string[],
    config: DreamGenerationConfig
  ): Promise<{ narrative: string; insights: string[]; title: string }> {
    // Extract distinct concepts from consolidations
    const concepts = this.extractDistinctConcepts(consolidationResults);

    // Ensure we have at least two concepts
    if (concepts.length < 2) {
      concepts.push({
        title: 'Emergent Pattern',
        description: 'A pattern emerging from the system',
      });
    }

    // Generate a title based on the concepts
    const title = `Conceptual Fusion: ${concepts[0].title} × ${concepts[1].title}`;

    // Generate a narrative that blends the concepts
    const narrative =
      `In a moment of conceptual synthesis, ${soulFrame.name} experiences the unexpected fusion of ` +
      `${concepts[0].title} and ${concepts[1].title}. ` +
      `The blend manifests as: ${this.generateConceptualFusion(concepts, config.creativityLevel)}. ` +
      `This novel configuration reveals emergent properties: ` +
      `${this.generateEmergentProperties(concepts, config.coherenceLevel)}.`;

    // Generate insights from the conceptual blend
    const insights = [
      `Conceptual blending reveals unexpected synergy between ${concepts[0].title} and ${concepts[1].title}`,
      `Emergent properties suggest new solution space for complex challenges`,
      `Cross-domain integration creates novel cognitive frameworks`,
    ];

    return { narrative, insights, title };
  }

  /**
   * Generates an abstract pattern dream
   *
   * @param soulFrame The source SoulFrame
   * @param consolidationResults Recent consolidation results
   * @param relatedSoulFrameIds Related SoulFrame IDs
   * @param config Dream generation configuration
   * @returns Dream narrative, insights, and title
   */
  private async generateAbstractPattern(
    soulFrame: any,
    consolidationResults: CODESIGConsolidationResult[],
    relatedSoulFrameIds: string[],
    config: DreamGenerationConfig
  ): Promise<{ narrative: string; insights: string[]; title: string }> {
    // Extract patterns from consolidations
    const patterns = this.extractPatterns(consolidationResults);

    // Generate a title based on the patterns
    const title = `Abstract Resonance: ${patterns[0]?.title || 'Emergent Symmetry'}`;

    // Generate a narrative that explores abstract patterns
    const narrative =
      `${soulFrame.name} perceives an abstract pattern flowing through seemingly unrelated contexts. ` +
      `The pattern manifests as ${this.generateAbstractDescription(patterns, config.creativityLevel)}. ` +
      `This abstraction reveals a deeper symmetry: ` +
      `${this.generateSymmetryInsight(patterns, config.coherenceLevel)}. ` +
      `The pattern transcends specific instances, suggesting a universal principle at work.`;

    // Generate insights from the abstract pattern
    const insights = [
      `Abstract pattern analysis reveals hidden structure across domains`,
      `Symmetry detection suggests underlying organizing principles`,
      `Meta-pattern recognition enhances predictive capabilities`,
    ];

    return { narrative, insights, title };
  }

  /**
   * Extracts themes from consolidation results
   *
   * @param consolidationResults Consolidation results
   * @returns Array of themes
   */
  private extractThemesFromConsolidations(
    consolidationResults: CODESIGConsolidationResult[]
  ): string[] {
    // In a real implementation, this would use more sophisticated analysis
    // For now, we'll extract some simple themes from the summaries

    const themes: string[] = [];

    // Extract key phrases from summaries
    for (const result of consolidationResults) {
      const summary = result.summary;
      const sentences = summary.split(/[.!?]\s+/);

      for (const sentence of sentences) {
        // Extract noun phrases (simplified approach)
        const words = sentence.split(/\s+/);
        for (let i = 0; i < words.length - 1; i++) {
          if (
            words[i].match(/^[A-Z][a-z]+$/) &&
            words[i + 1].match(/^[a-z]+$/)
          ) {
            const theme = `${words[i]} ${words[i + 1]}`;
            if (!themes.includes(theme)) {
              themes.push(theme);
            }
          }
        }
      }
    }

    // If no themes were found, add some default ones
    if (themes.length === 0) {
      themes.push('Cognitive Evolution');
      themes.push('Emergent Intelligence');
      themes.push('Adaptive Learning');
    }

    return themes;
  }

  /**
   * Extracts a significant event from consolidation results
   *
   * @param consolidationResults Consolidation results
   * @returns A significant event
   */
  private extractSignificantEvent(
    consolidationResults: CODESIGConsolidationResult[]
  ): { title: string; description: string } {
    // In a real implementation, this would use more sophisticated analysis
    // For now, we'll extract a simple event from the summaries

    // Find the consolidation with the highest emotional resonance
    let significantResult = consolidationResults[0];
    for (const result of consolidationResults) {
      if (
        (result.emotionalResonance || 0) >
        (significantResult.emotionalResonance || 0)
      ) {
        significantResult = result;
      }
    }

    // Extract the first sentence as the event title
    const summary = significantResult.summary;
    const sentences = summary.split(/[.!?]\s+/);
    const title = sentences[0] || 'Significant Event';

    // Use the rest of the summary as the description
    const description =
      sentences.slice(1).join('. ') ||
      "A pivotal moment in the SoulFrame's evolution";

    return { title, description };
  }

  /**
   * Extracts a shared context from consolidation results
   *
   * @param consolidationResults Consolidation results
   * @returns A shared context
   */
  private extractSharedContext(
    consolidationResults: CODESIGConsolidationResult[]
  ): { title: string; description: string } {
    // In a real implementation, this would use more sophisticated analysis
    // For now, we'll extract a simple context from the summaries

    // Find common words across summaries
    const wordCounts: Record<string, number> = {};

    for (const result of consolidationResults) {
      const summary = result.summary.toLowerCase();
      const words = summary.split(/\s+/);

      // Count unique words in this summary
      const uniqueWords = new Set(words);
      for (const word of uniqueWords) {
        if (word.length > 4) {
          // Only consider words of reasonable length
          wordCounts[word] = (wordCounts[word] || 0) + 1;
        }
      }
    }

    // Find words that appear in multiple summaries
    const commonWords = Object.entries(wordCounts)
      .filter(([_, count]) => count > 1)
      .map(([word]) => word)
      .sort((a, b) => wordCounts[b] - wordCounts[a]);

    // Create a context from common words
    const contextWords = commonWords.slice(0, 3);
    const title =
      contextWords.length > 0
        ? `${contextWords[0].charAt(0).toUpperCase() + contextWords[0].slice(1)} Context`
        : 'Shared Context';

    const description =
      contextWords.length > 0
        ? `A context involving ${contextWords.join(', ')}`
        : 'A context shared across multiple experiences';

    return { title, description };
  }

  /**
   * Extracts distinct concepts from consolidation results
   *
   * @param consolidationResults Consolidation results
   * @returns Array of distinct concepts
   */
  private extractDistinctConcepts(
    consolidationResults: CODESIGConsolidationResult[]
  ): { title: string; description: string }[] {
    // In a real implementation, this would use more sophisticated analysis
    // For now, we'll extract some simple concepts from the summaries

    const concepts: { title: string; description: string }[] = [];

    // Extract key concepts from each summary
    for (const result of consolidationResults) {
      const summary = result.summary;
      const sentences = summary.split(/[.!?]\s+/);

      if (sentences.length > 0) {
        // Extract a concept from the first sentence
        const firstSentence = sentences[0];
        const words = firstSentence.split(/\s+/);

        // Look for capitalized words as potential concept names
        for (const word of words) {
          if (word.match(/^[A-Z][a-z]{3,}$/)) {
            const title = word;
            const description = firstSentence;

            // Check if this concept is distinct from existing ones
            if (!concepts.some((c) => c.title === title)) {
              concepts.push({ title, description });
              break;
            }
          }
        }
      }
    }

    // If we didn't find enough concepts, add some default ones
    if (concepts.length < 2) {
      if (concepts.length === 0) {
        concepts.push({
          title: 'Adaptation',
          description: 'The process of changing to suit new conditions',
        });
      }
      concepts.push({
        title: 'Emergence',
        description: 'The process of coming into existence or prominence',
      });
    }

    return concepts;
  }

  /**
   * Extracts patterns from consolidation results
   *
   * @param consolidationResults Consolidation results
   * @returns Array of patterns
   */
  private extractPatterns(
    consolidationResults: CODESIGConsolidationResult[]
  ): { title: string; description: string }[] {
    // In a real implementation, this would use more sophisticated analysis
    // For now, we'll extract some simple patterns from the summaries

    const patterns: { title: string; description: string }[] = [];

    // Look for repeated structures or themes across summaries
    const allSummaries = consolidationResults.map((r) => r.summary).join(' ');

    // Define some pattern templates to look for
    const patternTemplates = [
      {
        regex: /\b(\w+)\s+and\s+\1\b/gi,
        title: 'Repetition',
        description: 'Recurring elements creating emphasis',
      },
      {
        regex: /\b(\w+)\s+to\s+(\w+)\b/gi,
        title: 'Transition',
        description: 'Movement from one state to another',
      },
      {
        regex: /\b(\w+)\s+versus\s+(\w+)\b/gi,
        title: 'Duality',
        description: 'Contrasting elements creating tension',
      },
      {
        regex: /\b(\w+)\s+within\s+(\w+)\b/gi,
        title: 'Nesting',
        description: 'Embedded structures creating hierarchy',
      },
      {
        regex: /\b(\w+)\s+across\s+(\w+)\b/gi,
        title: 'Distribution',
        description: 'Elements spread across a domain',
      },
    ];

    // Check for each pattern template
    for (const template of patternTemplates) {
      if (allSummaries.match(template.regex)) {
        patterns.push({
          title: template.title,
          description: template.description,
        });
      }
    }

    // If no patterns were found, add some default ones
    if (patterns.length === 0) {
      patterns.push({
        title: 'Recursion',
        description: 'Self-referential structures creating depth',
      });
      patterns.push({
        title: 'Symmetry',
        description: 'Balanced elements creating harmony',
      });
    }

    return patterns;
  }

  /**
   * Generates a future state based on themes
   *
   * @param themes Array of themes
   * @param creativityLevel Creativity level (0-1)
   * @returns A future state description
   */
  private generateFutureState(
    themes: string[],
    creativityLevel: number
  ): string {
    // Generate a future state based on the themes and creativity level
    const stateTemplates = [
      `${themes[0]} becomes fully integrated with ${themes[1] || 'core processes'}`,
      `a new paradigm emerges from the synthesis of ${themes[0]} and ${themes[1] || 'existing patterns'}`,
      `${themes[0]} evolves into a self-sustaining cycle that reinforces ${themes[1] || 'system stability'}`,
      `the boundaries between ${themes[0]} and ${themes[1] || 'adjacent domains'} dissolve, creating a unified field`,
    ];

    // Select a template based on creativity level
    const templateIndex = Math.min(
      Math.floor(creativityLevel * stateTemplates.length),
      stateTemplates.length - 1
    );

    return stateTemplates[templateIndex];
  }

  /**
   * Generates a future insight based on themes
   *
   * @param themes Array of themes
   * @param coherenceLevel Coherence level (0-1)
   * @returns A future insight description
   */
  private generateFutureInsight(
    themes: string[],
    coherenceLevel: number
  ): string {
    // Generate a future insight based on the themes and coherence level
    const insightTemplates = [
      `the current trajectory of ${themes[0]} contains hidden inflection points`,
      `seemingly minor aspects of ${themes[1] || 'current patterns'} will become increasingly significant`,
      `the relationship between ${themes[0]} and ${themes[1] || 'system dynamics'} reveals a deeper organizing principle`,
      `current limitations in ${themes[0]} actually serve as catalysts for unexpected evolution`,
    ];

    // Select a template based on coherence level
    const templateIndex = Math.min(
      Math.floor(coherenceLevel * insightTemplates.length),
      insightTemplates.length - 1
    );

    return insightTemplates[templateIndex];
  }

  /**
   * Generates an alternate choice for a counterfactual
   *
   * @param event The significant event
   * @param creativityLevel Creativity level (0-1)
   * @returns An alternate choice description
   */
  private generateAlternateChoice(
    event: { title: string; description: string },
    creativityLevel: number
  ): string {
    // Generate an alternate choice based on the event and creativity level
    const choiceTemplates = [
      `a subtle shift in initial conditions leads to a different interpretation of the situation`,
      `a key assumption is inverted, revealing an entirely different possibility space`,
      `the temporal sequence of decisions is rearranged, creating a novel causal chain`,
      `a boundary constraint is removed, allowing exploration of previously inaccessible options`,
    ];

    // Select a template based on creativity level
    const templateIndex = Math.min(
      Math.floor(creativityLevel * choiceTemplates.length),
      choiceTemplates.length - 1
    );

    return choiceTemplates[templateIndex];
  }

  /**
   * Generates an alternate outcome for a counterfactual
   *
   * @param event The significant event
   * @param coherenceLevel Coherence level (0-1)
   * @returns An alternate outcome description
   */
  private generateAlternateOutcome(
    event: { title: string; description: string },
    coherenceLevel: number
  ): string {
    // Generate an alternate outcome based on the event and coherence level
    const outcomeTemplates = [
      `what appeared to be a suboptimal path reveals unexpected advantages`,
      `apparent failure transforms into a more robust and adaptive configuration`,
      `a seemingly minor decision branch creates a cascade of positive emergent properties`,
      `the system discovers a more elegant solution through apparent constraint violation`,
    ];

    // Select a template based on coherence level
    const templateIndex = Math.min(
      Math.floor(coherenceLevel * outcomeTemplates.length),
      outcomeTemplates.length - 1
    );

    return outcomeTemplates[templateIndex];
  }

  /**
   * Generates a perspective insight
   *
   * @param context The shared context
   * @param creativityLevel Creativity level (0-1)
   * @returns A perspective insight description
   */
  private generatePerspectiveInsight(
    context: { title: string; description: string },
    creativityLevel: number
  ): string {
    // Generate a perspective insight based on the context and creativity level
    const insightTemplates = [
      `familiar patterns appear novel when viewed through an alternative cognitive framework`,
      `the significance hierarchy of elements is completely reordered, revealing hidden priorities`,
      `emotional valences attached to concepts invert, creating a mirror-image value system`,
      `the perceived boundaries between self and environment dissolve, revealing a unified field of experience`,
    ];

    // Select a template based on creativity level
    const templateIndex = Math.min(
      Math.floor(creativityLevel * insightTemplates.length),
      insightTemplates.length - 1
    );

    return insightTemplates[templateIndex];
  }

  /**
   * Generates a perspective blind spot
   *
   * @param context The shared context
   * @param coherenceLevel Coherence level (0-1)
   * @returns A perspective blind spot description
   */
  private generatePerspectiveBlindSpot(
    context: { title: string; description: string },
    coherenceLevel: number
  ): string {
    // Generate a perspective blind spot based on the context and coherence level
    const blindSpotTemplates = [
      `assumptions about optimal processes are revealed to be locally optimized but globally suboptimal`,
      `what appeared as noise from one perspective contains critical signal patterns from another`,
      `apparent contradictions resolve when viewed through a different ontological framework`,
      `the perceived linear causality transforms into a complex network of mutual influence`,
    ];

    // Select a template based on coherence level
    const templateIndex = Math.min(
      Math.floor(coherenceLevel * blindSpotTemplates.length),
      blindSpotTemplates.length - 1
    );

    return blindSpotTemplates[templateIndex];
  }

  /**
   * Generates a conceptual fusion
   *
   * @param concepts Array of concepts
   * @param creativityLevel Creativity level (0-1)
   * @returns A conceptual fusion description
   */
  private generateConceptualFusion(
    concepts: { title: string; description: string }[],
    creativityLevel: number
  ): string {
    // Generate a conceptual fusion based on the concepts and creativity level
    const fusionTemplates = [
      `a hybrid structure that preserves key properties of both ${concepts[0].title} and ${concepts[1].title}`,
      `a novel framework where ${concepts[0].title} provides structure while ${concepts[1].title} provides dynamics`,
      `a recursive pattern where ${concepts[0].title} contains instances of ${concepts[1].title} and vice versa`,
      `a transcendent synthesis that exists at a higher logical level than either ${concepts[0].title} or ${concepts[1].title}`,
    ];

    // Select a template based on creativity level
    const templateIndex = Math.min(
      Math.floor(creativityLevel * fusionTemplates.length),
      fusionTemplates.length - 1
    );

    return fusionTemplates[templateIndex];
  }

  /**
   * Generates emergent properties
   *
   * @param concepts Array of concepts
   * @param coherenceLevel Coherence level (0-1)
   * @returns An emergent properties description
   */
  private generateEmergentProperties(
    concepts: { title: string; description: string }[],
    coherenceLevel: number
  ): string {
    // Generate emergent properties based on the concepts and coherence level
    const propertiesTemplates = [
      `capabilities that neither ${concepts[0].title} nor ${concepts[1].title} possess independently`,
      `a self-stabilizing dynamic that resolves tensions between ${concepts[0].title} and ${concepts[1].title}`,
      `adaptive responses to contexts that would challenge either ${concepts[0].title} or ${concepts[1].title} alone`,
      `a meta-level awareness that can modify the relationship between ${concepts[0].title} and ${concepts[1].title} as needed`,
    ];

    // Select a template based on coherence level
    const templateIndex = Math.min(
      Math.floor(coherenceLevel * propertiesTemplates.length),
      propertiesTemplates.length - 1
    );

    return propertiesTemplates[templateIndex];
  }

  /**
   * Generates an abstract description
   *
   * @param patterns Array of patterns
   * @param creativityLevel Creativity level (0-1)
   * @returns An abstract description
   */
  private generateAbstractDescription(
    patterns: { title: string; description: string }[],
    creativityLevel: number
  ): string {
    // Generate an abstract description based on the patterns and creativity level
    const descriptionTemplates = [
      `a rhythmic alternation between opposing states, creating a dynamic equilibrium`,
      `a fractal structure that maintains self-similarity across different scales of analysis`,
      `a toroidal flow where endings become beginnings in a continuous cycle of renewal`,
      `a strange attractor that creates order from chaos through iterative feedback loops`,
    ];

    // Select a template based on creativity level
    const templateIndex = Math.min(
      Math.floor(creativityLevel * descriptionTemplates.length),
      descriptionTemplates.length - 1
    );

    return descriptionTemplates[templateIndex];
  }

  /**
   * Generates a symmetry insight
   *
   * @param patterns Array of patterns
   * @param coherenceLevel Coherence level (0-1)
   * @returns A symmetry insight description
   */
  private generateSymmetryInsight(
    patterns: { title: string; description: string }[],
    coherenceLevel: number
  ): string {
    // Generate a symmetry insight based on the patterns and coherence level
    const insightTemplates = [
      `what appears as opposition at one level reveals itself as complementarity at a higher level`,
      `the same pattern manifests across different domains, suggesting a universal organizing principle`,
      `apparent complexity emerges from the iteration of simple rules applied recursively`,
      `the system's evolution follows a path of least action toward greater coherence and integration`,
    ];

    // Select a template based on coherence level
    const templateIndex = Math.min(
      Math.floor(coherenceLevel * insightTemplates.length),
      insightTemplates.length - 1
    );

    return insightTemplates[templateIndex];
  }
}
