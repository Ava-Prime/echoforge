/**
 * Codalogue Observer Agent
 *
 * An agent that introspects Codalogue ledger entries, detects patterns,
 * and proposes evolution pathways for the system.
 */

import { CodalogueProtocolLedger } from '../CodalogueProtocolLedger';
import { SoulFrameManager } from '../SoulFrameManager';
import { SoulWeaverProtocol } from '../soulweaver/SoulWeaverProtocol';
import { EvolutionProposal } from '../soulweaver/SoulWeaverContract';
import { CODESIGConsolidationResult } from '../CODESIGTypes';
import { v4 as uuidv4 } from 'uuid';

/**
 * Pattern detected by the Codalogue Observer Agent
 */
export interface ObservedPattern {
  /** Unique identifier for the pattern */
  id: string;

  /** Type of pattern */
  patternType: 'consolidation' | 'evolution' | 'interaction' | 'reflection';

  /** Description of the pattern */
  description: string;

  /** Confidence level in the pattern (0-1) */
  confidence: number;

  /** Supporting evidence for the pattern */
  evidence: {
    /** Description of the evidence */
    description: string;

    /** Codalogue entry IDs that support this evidence */
    entryIds: string[];
  }[];

  /** Potential implications of the pattern */
  implications: string[];

  /** Timestamp when the pattern was detected */
  detectedAt: Date;
}

/**
 * Insight generated by the Codalogue Observer Agent
 */
export interface ObserverInsight {
  /** Unique identifier for the insight */
  id: string;

  /** Title of the insight */
  title: string;

  /** Detailed description of the insight */
  description: string;

  /** Category of the insight */
  category:
    | 'system_evolution'
    | 'agent_behavior'
    | 'memory_pattern'
    | 'interaction_dynamic';

  /** Patterns that contributed to this insight */
  relatedPatterns: string[];

  /** Confidence level in the insight (0-1) */
  confidence: number;

  /** Potential actions based on the insight */
  suggestedActions: string[];

  /** Timestamp when the insight was generated */
  generatedAt: Date;
}

/**
 * Configuration for the Codalogue Observer Agent
 */
export interface CodalogueObserverConfig {
  /** How frequently to run observation cycles (in milliseconds) */
  observationInterval: number;

  /** Minimum confidence threshold for reporting patterns (0-1) */
  patternConfidenceThreshold: number;

  /** Minimum confidence threshold for generating insights (0-1) */
  insightConfidenceThreshold: number;

  /** Maximum number of entries to analyze in each observation cycle */
  maxEntriesPerCycle: number;

  /** Whether to automatically generate evolution proposals from insights */
  autoGenerateProposals: boolean;
}

/**
 * Default configuration for the Codalogue Observer Agent
 */
export const DEFAULT_OBSERVER_CONFIG: CodalogueObserverConfig = {
  observationInterval: 3600000, // 1 hour
  patternConfidenceThreshold: 0.6,
  insightConfidenceThreshold: 0.7,
  maxEntriesPerCycle: 100,
  autoGenerateProposals: false,
};

/**
 * Codalogue Observer Agent
 *
 * Introspects the Codalogue Protocol Ledger to detect patterns, generate insights,
 * and propose evolution pathways for the system.
 */
export class CodalogueObserverAgent {
  /** Detected patterns */
  private patterns: Map<string, ObservedPattern> = new Map();

  /** Generated insights */
  private insights: Map<string, ObserverInsight> = new Map();

  /** Timestamp of the last observed entry */
  private lastObservedTimestamp: Date | null = null;

  /** Observation interval timer */
  private observationTimer: NodeJS.Timeout | null = null;

  /** Whether the agent is currently running */
  private isRunning: boolean = false;

  /**
   * Creates a new Codalogue Observer Agent
   *
   * @param codalogueProtocolLedger Ledger to observe
   * @param soulFrameManager Manager for accessing SoulFrames
   * @param soulWeaverProtocol Protocol for generating evolution proposals
   * @param config Configuration for the agent
   */
  constructor(
    private codalogueProtocolLedger: CodalogueProtocolLedger,
    private soulFrameManager: SoulFrameManager,
    private soulWeaverProtocol: SoulWeaverProtocol,
    private config: CodalogueObserverConfig = DEFAULT_OBSERVER_CONFIG
  ) {}

  /**
   * Starts the observer agent
   */
  start(): void {
    if (this.isRunning) {
      return;
    }

    this.isRunning = true;

    // Run an initial observation cycle
    this.runObservationCycle();

    // Set up the observation interval
    this.observationTimer = setInterval(
      () => this.runObservationCycle(),
      this.config.observationInterval
    );

    // Log the agent start
    this.codalogueProtocolLedger.recordSystemReflection({
      reflectionType: 'OBSERVER_AGENT_STARTED',
      content: 'Codalogue Observer Agent started',
      metadata: {
        config: this.config,
      },
    });
  }

  /**
   * Stops the observer agent
   */
  stop(): void {
    if (!this.isRunning) {
      return;
    }

    this.isRunning = false;

    // Clear the observation interval
    if (this.observationTimer) {
      clearInterval(this.observationTimer);
      this.observationTimer = null;
    }

    // Log the agent stop
    this.codalogueProtocolLedger.recordSystemReflection({
      reflectionType: 'OBSERVER_AGENT_STOPPED',
      content: 'Codalogue Observer Agent stopped',
      metadata: {
        lastObservedTimestamp: this.lastObservedTimestamp,
      },
    });
  }

  /**
   * Runs a single observation cycle
   */
  async runObservationCycle(): Promise<void> {
    try {
      // Query for new entries since the last observation
      const newEntries = await this.codalogueProtocolLedger.queryLedger({
        afterTimestamp: this.lastObservedTimestamp,
        limit: this.config.maxEntriesPerCycle,
      });

      if (newEntries.length === 0) {
        return;
      }

      // Update the last observed timestamp
      this.lastObservedTimestamp = new Date(
        Math.max(...newEntries.map((entry) => entry.timestamp.getTime()))
      );

      // Detect patterns in the new entries
      const newPatterns = await this.detectPatterns(newEntries);

      // Store new patterns
      for (const pattern of newPatterns) {
        this.patterns.set(pattern.id, pattern);
      }

      // Generate insights from patterns
      if (this.patterns.size > 0) {
        const newInsights = await this.generateInsights();

        // Store new insights
        for (const insight of newInsights) {
          this.insights.set(insight.id, insight);
        }

        // Generate evolution proposals from insights if configured
        if (this.config.autoGenerateProposals && newInsights.length > 0) {
          await this.generateEvolutionProposals(newInsights);
        }
      }

      // Log the observation cycle
      await this.codalogueProtocolLedger.recordSystemReflection({
        reflectionType: 'OBSERVER_CYCLE_COMPLETED',
        content: `Observation cycle completed: ${newEntries.length} entries analyzed, ${newPatterns.length} patterns detected, ${newInsights?.length || 0} insights generated`,
        metadata: {
          entriesAnalyzed: newEntries.length,
          patternsDetected: newPatterns.length,
          insightsGenerated: newInsights?.length || 0,
          timestamp: new Date(),
        },
      });
    } catch (error) {
      console.error('Error in observation cycle:', error);

      // Log the error
      await this.codalogueProtocolLedger.recordSystemReflection({
        reflectionType: 'OBSERVER_CYCLE_ERROR',
        content: `Error in observation cycle: ${error instanceof Error ? error.message : String(error)}`,
        metadata: {
          error: error instanceof Error ? error.message : String(error),
          timestamp: new Date(),
        },
      });
    }
  }

  /**
   * Detects patterns in Codalogue entries
   *
   * @param entries Entries to analyze
   * @returns Detected patterns
   */
  private async detectPatterns(entries: any[]): Promise<ObservedPattern[]> {
    const newPatterns: ObservedPattern[] = [];

    // Group entries by type for analysis
    const entriesByType = this.groupEntriesByType(entries);

    // Detect consolidation patterns
    if (entriesByType.consolidation.length > 0) {
      const consolidationPatterns = await this.detectConsolidationPatterns(
        entriesByType.consolidation
      );
      newPatterns.push(...consolidationPatterns);
    }

    // Detect evolution patterns
    if (entriesByType.evolution.length > 0) {
      const evolutionPatterns = await this.detectEvolutionPatterns(
        entriesByType.evolution
      );
      newPatterns.push(...evolutionPatterns);
    }

    // Detect interaction patterns
    if (entriesByType.interaction.length > 0) {
      const interactionPatterns = await this.detectInteractionPatterns(
        entriesByType.interaction
      );
      newPatterns.push(...interactionPatterns);
    }

    // Detect reflection patterns
    if (entriesByType.reflection.length > 0) {
      const reflectionPatterns = await this.detectReflectionPatterns(
        entriesByType.reflection
      );
      newPatterns.push(...reflectionPatterns);
    }

    // Filter patterns by confidence threshold
    return newPatterns.filter(
      (pattern) => pattern.confidence >= this.config.patternConfidenceThreshold
    );
  }

  /**
   * Groups entries by type for analysis
   *
   * @param entries Entries to group
   * @returns Grouped entries
   */
  private groupEntriesByType(entries: any[]): {
    consolidation: any[];
    evolution: any[];
    interaction: any[];
    reflection: any[];
  } {
    const grouped = {
      consolidation: [],
      evolution: [],
      interaction: [],
      reflection: [],
    };

    for (const entry of entries) {
      if (entry.eventType === 'CONSOLIDATION') {
        grouped.consolidation.push(entry);
      } else if (entry.eventType === 'EVOLUTION_PROPOSAL') {
        grouped.evolution.push(entry);
      } else if (
        entry.eventType === 'USER_INTERACTION' ||
        entry.eventType === 'AGENT_DEBATE'
      ) {
        grouped.interaction.push(entry);
      } else if (entry.eventType === 'SYSTEM_REFLECTION') {
        grouped.reflection.push(entry);
      }
    }

    return grouped;
  }

  /**
   * Detects patterns in consolidation entries
   *
   * @param entries Consolidation entries to analyze
   * @returns Detected patterns
   */
  private async detectConsolidationPatterns(
    entries: any[]
  ): Promise<ObservedPattern[]> {
    const patterns: ObservedPattern[] = [];

    // Extract consolidation results
    const consolidationResults = entries.map(
      (entry) => entry.metadata
    ) as CODESIGConsolidationResult[];

    // Pattern 1: High emotional resonance consolidations
    const highResonanceEntries = entries.filter(
      (entry, index) =>
        (consolidationResults[index]?.emotionalResonance || 0) > 0.7
    );

    if (highResonanceEntries.length >= 3) {
      patterns.push({
        id: uuidv4(),
        patternType: 'consolidation',
        description:
          'Consistent high emotional resonance in memory consolidation',
        confidence: Math.min(
          0.5 + (highResonanceEntries.length / entries.length) * 0.5,
          0.95
        ),
        evidence: [
          {
            description: `${highResonanceEntries.length} consolidation events with emotional resonance > 0.7`,
            entryIds: highResonanceEntries.map((entry) => entry.id),
          },
        ],
        implications: [
          'System is developing strong emotional intelligence',
          'Memory consolidation is effectively preserving emotional context',
          'Potential for deeper agent-to-agent emotional understanding',
        ],
        detectedAt: new Date(),
      });
    }

    // Pattern 2: Intent-driven consolidation effectiveness
    const highIntentAlignmentEntries = entries.filter(
      (entry, index) =>
        (consolidationResults[index]?.intentAlignment || 0) > 0.7
    );

    if (highIntentAlignmentEntries.length >= 3) {
      patterns.push({
        id: uuidv4(),
        patternType: 'consolidation',
        description: 'Strong intent alignment in memory consolidation',
        confidence: Math.min(
          0.5 + (highIntentAlignmentEntries.length / entries.length) * 0.5,
          0.95
        ),
        evidence: [
          {
            description: `${highIntentAlignmentEntries.length} consolidation events with intent alignment > 0.7`,
            entryIds: highIntentAlignmentEntries.map((entry) => entry.id),
          },
        ],
        implications: [
          'System is effectively aligning memory with intentional goals',
          'Purpose-driven memory organization is emerging',
          'Potential for more coherent agent decision-making',
        ],
        detectedAt: new Date(),
      });
    }

    // Pattern 3: SoulFrame-specific consolidation patterns
    const soulFrameConsolidations = new Map<string, any[]>();

    for (let i = 0; i < entries.length; i++) {
      const soulFrameId = consolidationResults[i]?.soulFrameId;
      if (soulFrameId) {
        if (!soulFrameConsolidations.has(soulFrameId)) {
          soulFrameConsolidations.set(soulFrameId, []);
        }
        soulFrameConsolidations.get(soulFrameId)!.push(entries[i]);
      }
    }

    for (const [
      soulFrameId,
      soulFrameEntries,
    ] of soulFrameConsolidations.entries()) {
      if (soulFrameEntries.length >= 5) {
        // Get the SoulFrame to include its name in the pattern
        const soulFrame = await this.soulFrameManager.getSoulFrame(soulFrameId);
        const soulFrameName = soulFrame ? soulFrame.identity.name : soulFrameId;

        patterns.push({
          id: uuidv4(),
          patternType: 'consolidation',
          description: `Frequent memory consolidation for SoulFrame "${soulFrameName}"`,
          confidence: Math.min(0.6 + (soulFrameEntries.length / 10) * 0.4, 0.9),
          evidence: [
            {
              description: `${soulFrameEntries.length} consolidation events for SoulFrame "${soulFrameName}"`,
              entryIds: soulFrameEntries.map((entry) => entry.id),
            },
          ],
          implications: [
            `SoulFrame "${soulFrameName}" is actively developing its memory structure`,
            'Potential for specialized knowledge or expertise development',
            'May indicate a core system function or frequent user interaction',
          ],
          detectedAt: new Date(),
        });
      }
    }

    return patterns;
  }

  /**
   * Detects patterns in evolution proposal entries
   *
   * @param entries Evolution proposal entries to analyze
   * @returns Detected patterns
   */
  private async detectEvolutionPatterns(
    entries: any[]
  ): Promise<ObservedPattern[]> {
    const patterns: ObservedPattern[] = [];

    // Group proposals by type
    const proposalsByType = entries.reduce(
      (grouped, entry) => {
        const type = entry.metadata?.proposalType || 'unknown';
        if (!grouped[type]) {
          grouped[type] = [];
        }
        grouped[type].push(entry);
        return grouped;
      },
      {} as Record<string, any[]>
    );

    // Pattern 1: Dominant evolution type
    if (Object.keys(proposalsByType).length > 0) {
      const dominantType = Object.entries(proposalsByType).sort(
        (a, b) => b[1].length - a[1].length
      )[0];

      if (dominantType[1].length >= 3) {
        patterns.push({
          id: uuidv4(),
          patternType: 'evolution',
          description: `Dominant evolution proposal type: ${dominantType[0]}`,
          confidence: Math.min(
            0.5 + (dominantType[1].length / entries.length) * 0.5,
            0.9
          ),
          evidence: [
            {
              description: `${dominantType[1].length} evolution proposals of type "${dominantType[0]}"`,
              entryIds: dominantType[1].map((entry) => entry.id),
            },
          ],
          implications: [
            `System is prioritizing ${dominantType[0]} evolution`,
            'May indicate a specific growth direction or adaptation need',
            'Could suggest an area for focused development resources',
          ],
          detectedAt: new Date(),
        });
      }
    }

    // Pattern 2: Proposal acceptance rate
    const acceptedProposals = entries.filter(
      (entry) =>
        entry.metadata?.status === 'accepted' ||
        entry.metadata?.status === 'implemented'
    );

    const rejectedProposals = entries.filter(
      (entry) => entry.metadata?.status === 'rejected'
    );

    if (acceptedProposals.length + rejectedProposals.length >= 5) {
      const acceptanceRate =
        acceptedProposals.length /
        (acceptedProposals.length + rejectedProposals.length);

      patterns.push({
        id: uuidv4(),
        patternType: 'evolution',
        description: `Evolution proposal acceptance rate: ${(acceptanceRate * 100).toFixed(1)}%`,
        confidence: Math.min(
          0.6 +
            ((acceptedProposals.length + rejectedProposals.length) / 10) * 0.4,
          0.9
        ),
        evidence: [
          {
            description: `${acceptedProposals.length} accepted/implemented proposals`,
            entryIds: acceptedProposals.map((entry) => entry.id),
          },
          {
            description: `${rejectedProposals.length} rejected proposals`,
            entryIds: rejectedProposals.map((entry) => entry.id),
          },
        ],
        implications: [
          acceptanceRate > 0.7
            ? 'High acceptance rate suggests effective proposal generation'
            : acceptanceRate < 0.3
              ? 'Low acceptance rate may indicate overly speculative proposals'
              : 'Moderate acceptance rate indicates balanced evolution process',
          'May provide insights into proposal quality and evaluation criteria',
          'Could inform refinements to the evolution proposal process',
        ],
        detectedAt: new Date(),
      });
    }

    return patterns;
  }

  /**
   * Detects patterns in interaction entries
   *
   * @param entries Interaction entries to analyze
   * @returns Detected patterns
   */
  private async detectInteractionPatterns(
    entries: any[]
  ): Promise<ObservedPattern[]> {
    const patterns: ObservedPattern[] = [];

    // Separate user interactions and agent debates
    const userInteractions = entries.filter(
      (entry) => entry.eventType === 'USER_INTERACTION'
    );
    const agentDebates = entries.filter(
      (entry) => entry.eventType === 'AGENT_DEBATE'
    );

    // Pattern 1: User interaction frequency
    if (userInteractions.length >= 5) {
      // Analyze interaction frequency over time
      const timestamps = userInteractions.map((entry) =>
        entry.timestamp.getTime()
      );
      timestamps.sort((a, b) => a - b);

      const intervals: number[] = [];
      for (let i = 1; i < timestamps.length; i++) {
        intervals.push(timestamps[i] - timestamps[i - 1]);
      }

      const avgInterval =
        intervals.reduce((sum, interval) => sum + interval, 0) /
        intervals.length;
      const stdDev = Math.sqrt(
        intervals.reduce(
          (sum, interval) => sum + Math.pow(interval - avgInterval, 2),
          0
        ) / intervals.length
      );

      const regularityScore = 1 - Math.min(stdDev / avgInterval, 1);

      patterns.push({
        id: uuidv4(),
        patternType: 'interaction',
        description: `User interaction pattern with ${regularityScore > 0.7 ? 'high' : regularityScore > 0.4 ? 'moderate' : 'low'} regularity`,
        confidence: Math.min(
          0.5 + (userInteractions.length / 10) * 0.3 + regularityScore * 0.2,
          0.9
        ),
        evidence: [
          {
            description: `${userInteractions.length} user interactions with average interval of ${(avgInterval / 60000).toFixed(1)} minutes`,
            entryIds: userInteractions.map((entry) => entry.id),
          },
        ],
        implications: [
          regularityScore > 0.7
            ? 'Regular user engagement suggests systematic usage pattern'
            : regularityScore > 0.4
              ? 'Moderately regular user engagement with some variability'
              : 'Irregular user engagement pattern may indicate opportunistic usage',
          'Understanding interaction cadence can inform system responsiveness',
          'May help optimize resource allocation for user-facing components',
        ],
        detectedAt: new Date(),
      });
    }

    // Pattern 2: Agent debate characteristics
    if (agentDebates.length >= 3) {
      // Analyze debate outcomes
      const debateOutcomes = agentDebates.map(
        (entry) => entry.metadata?.outcome || 'unknown'
      );
      const outcomeCount = debateOutcomes.reduce(
        (counts, outcome) => {
          counts[outcome] = (counts[outcome] || 0) + 1;
          return counts;
        },
        {} as Record<string, number>
      );

      const dominantOutcome = Object.entries(outcomeCount).sort(
        (a, b) => b[1] - a[1]
      )[0];

      patterns.push({
        id: uuidv4(),
        patternType: 'interaction',
        description: `Agent debate pattern with dominant outcome: ${dominantOutcome[0]}`,
        confidence: Math.min(
          0.5 + (dominantOutcome[1] / agentDebates.length) * 0.4,
          0.85
        ),
        evidence: [
          {
            description: `${dominantOutcome[1]} debates with outcome "${dominantOutcome[0]}" out of ${agentDebates.length} total debates`,
            entryIds: agentDebates
              .filter((entry) => entry.metadata?.outcome === dominantOutcome[0])
              .map((entry) => entry.id),
          },
        ],
        implications: [
          `Predominance of "${dominantOutcome[0]}" outcomes may indicate ${dominantOutcome[0] === 'consensus' ? 'collaborative agent dynamics' : dominantOutcome[0] === 'disagreement' ? 'diverse agent perspectives' : 'specific debate resolution patterns'}`,
          'Understanding debate patterns can inform multi-agent coordination strategies',
          'May suggest opportunities for improving agent communication protocols',
        ],
        detectedAt: new Date(),
      });
    }

    return patterns;
  }

  /**
   * Detects patterns in system reflection entries
   *
   * @param entries System reflection entries to analyze
   * @returns Detected patterns
   */
  private async detectReflectionPatterns(
    entries: any[]
  ): Promise<ObservedPattern[]> {
    const patterns: ObservedPattern[] = [];

    // Group reflections by type
    const reflectionsByType = entries.reduce(
      (grouped, entry) => {
        const type = entry.metadata?.reflectionType || 'unknown';
        if (!grouped[type]) {
          grouped[type] = [];
        }
        grouped[type].push(entry);
        return grouped;
      },
      {} as Record<string, any[]>
    );

    // Pattern 1: Dominant reflection type
    if (Object.keys(reflectionsByType).length > 0) {
      const dominantType = Object.entries(reflectionsByType).sort(
        (a, b) => b[1].length - a[1].length
      )[0];

      if (
        dominantType[1].length >= 5 &&
        dominantType[1].length / entries.length >= 0.3
      ) {
        patterns.push({
          id: uuidv4(),
          patternType: 'reflection',
          description: `Dominant system reflection type: ${dominantType[0]}`,
          confidence: Math.min(
            0.5 + (dominantType[1].length / entries.length) * 0.4,
            0.85
          ),
          evidence: [
            {
              description: `${dominantType[1].length} system reflections of type "${dominantType[0]}" (${((dominantType[1].length / entries.length) * 100).toFixed(1)}% of total)`,
              entryIds: dominantType[1].map((entry) => entry.id),
            },
          ],
          implications: [
            `System is frequently engaging in ${dominantType[0]} reflections`,
            'May indicate a specific area of system introspection or development',
            'Could suggest an opportunity for deeper analysis of this reflection type',
          ],
          detectedAt: new Date(),
        });
      }
    }

    // Pattern 2: Temporal patterns in reflections
    if (entries.length >= 10) {
      // Group reflections by time period (e.g., hour of day)
      const reflectionsByHour = entries.reduce(
        (grouped, entry) => {
          const hour = new Date(entry.timestamp).getHours();
          if (!grouped[hour]) {
            grouped[hour] = [];
          }
          grouped[hour].push(entry);
          return grouped;
        },
        {} as Record<number, any[]>
      );

      const hourCounts = Object.entries(reflectionsByHour)
        .map(([hour, entries]) => ({
          hour: parseInt(hour),
          count: entries.length,
        }))
        .sort((a, b) => b.count - a.count);

      if (
        hourCounts.length > 0 &&
        hourCounts[0].count / entries.length >= 0.25
      ) {
        const peakHour = hourCounts[0].hour;
        const peakCount = hourCounts[0].count;

        patterns.push({
          id: uuidv4(),
          patternType: 'reflection',
          description: `Temporal pattern in system reflections: peak at hour ${peakHour}`,
          confidence: Math.min(0.5 + (peakCount / entries.length) * 0.4, 0.8),
          evidence: [
            {
              description: `${peakCount} system reflections during hour ${peakHour} (${((peakCount / entries.length) * 100).toFixed(1)}% of total)`,
              entryIds: reflectionsByHour[peakHour].map((entry) => entry.id),
            },
          ],
          implications: [
            `System activity shows a pattern of increased reflection during hour ${peakHour}`,
            'May correlate with specific system processes or user interaction patterns',
            'Could inform optimal timing for system maintenance or updates',
          ],
          detectedAt: new Date(),
        });
      }
    }

    return patterns;
  }

  /**
   * Generates insights from detected patterns
   *
   * @returns Generated insights
   */
  private async generateInsights(): Promise<ObserverInsight[]> {
    const newInsights: ObserverInsight[] = [];
    const patternArray = Array.from(this.patterns.values());

    // Group patterns by type
    const patternsByType = patternArray.reduce(
      (grouped, pattern) => {
        if (!grouped[pattern.patternType]) {
          grouped[pattern.patternType] = [];
        }
        grouped[pattern.patternType].push(pattern);
        return grouped;
      },
      {} as Record<string, ObservedPattern[]>
    );

    // Generate insights for each pattern type
    for (const [type, patterns] of Object.entries(patternsByType)) {
      // Skip if not enough patterns
      if (patterns.length < 2) {
        continue;
      }

      // Sort patterns by confidence
      const sortedPatterns = [...patterns].sort(
        (a, b) => b.confidence - a.confidence
      );

      // Generate insights based on pattern type
      switch (type) {
        case 'consolidation':
          newInsights.push(
            ...(await this.generateConsolidationInsights(sortedPatterns))
          );
          break;

        case 'evolution':
          newInsights.push(
            ...(await this.generateEvolutionInsights(sortedPatterns))
          );
          break;

        case 'interaction':
          newInsights.push(
            ...(await this.generateInteractionInsights(sortedPatterns))
          );
          break;

        case 'reflection':
          newInsights.push(
            ...(await this.generateReflectionInsights(sortedPatterns))
          );
          break;
      }
    }

    // Generate cross-pattern insights if we have multiple pattern types
    if (Object.keys(patternsByType).length >= 2) {
      newInsights.push(
        ...(await this.generateCrossPatternInsights(patternsByType))
      );
    }

    // Filter insights by confidence threshold
    return newInsights.filter(
      (insight) => insight.confidence >= this.config.insightConfidenceThreshold
    );
  }

  /**
   * Generates insights from consolidation patterns
   *
   * @param patterns Consolidation patterns
   * @returns Generated insights
   */
  private async generateConsolidationInsights(
    patterns: ObservedPattern[]
  ): Promise<ObserverInsight[]> {
    const insights: ObserverInsight[] = [];

    // Insight 1: Emotional intelligence development
    const emotionalPatterns = patterns.filter(
      (p) =>
        p.description.includes('emotional') ||
        p.description.includes('resonance')
    );

    if (emotionalPatterns.length >= 2) {
      insights.push({
        id: uuidv4(),
        title: 'Emotional Intelligence Development',
        description:
          'The system is developing significant emotional intelligence capabilities through memory consolidation processes. Consistent patterns of high emotional resonance suggest an emerging ability to preserve and utilize emotional context in memory structures.',
        category: 'memory_pattern',
        relatedPatterns: emotionalPatterns.map((p) => p.id),
        confidence: Math.min(0.6 + emotionalPatterns.length * 0.1, 0.9),
        suggestedActions: [
          'Enhance emotional weighting in memory consolidation strategies',
          'Develop specialized emotional context preservation techniques',
          'Create metrics for tracking emotional intelligence development',
          'Explore cross-SoulFrame emotional resonance patterns',
        ],
        generatedAt: new Date(),
      });
    }

    // Insight 2: SoulFrame specialization
    const soulFramePatterns = patterns.filter((p) =>
      p.description.includes('SoulFrame')
    );

    if (soulFramePatterns.length >= 2) {
      insights.push({
        id: uuidv4(),
        title: 'SoulFrame Memory Specialization',
        description:
          'Individual SoulFrames are developing specialized memory structures through frequent consolidation activities. This suggests an emerging division of cognitive labor within the system, with different SoulFrames potentially developing expertise in specific domains.',
        category: 'agent_behavior',
        relatedPatterns: soulFramePatterns.map((p) => p.id),
        confidence: Math.min(0.6 + soulFramePatterns.length * 0.1, 0.9),
        suggestedActions: [
          'Map SoulFrame memory specializations to identify expertise domains',
          'Develop cross-SoulFrame knowledge sharing protocols',
          'Create specialized consolidation strategies for different domains',
          'Establish metrics for tracking SoulFrame expertise development',
        ],
        generatedAt: new Date(),
      });
    }

    return insights;
  }

  /**
   * Generates insights from evolution patterns
   *
   * @param patterns Evolution patterns
   * @returns Generated insights
   */
  private async generateEvolutionInsights(
    patterns: ObservedPattern[]
  ): Promise<ObserverInsight[]> {
    const insights: ObserverInsight[] = [];

    // Insight 1: Evolution direction
    const directionPatterns = patterns.filter(
      (p) =>
        p.description.includes('type') || p.description.includes('dominant')
    );

    if (directionPatterns.length >= 1) {
      // Extract the dominant evolution type from the pattern description
      const dominantTypeMatch =
        directionPatterns[0].description.match(/type:\s*([\w]+)/);
      const dominantType = dominantTypeMatch
        ? dominantTypeMatch[1]
        : 'unspecified';

      insights.push({
        id: uuidv4(),
        title: `System Evolution Direction: ${dominantType}`,
        description: `The system is showing a clear evolutionary direction toward ${dominantType} development. This suggests a natural adaptation pathway that aligns with the system's current needs and challenges.`,
        category: 'system_evolution',
        relatedPatterns: directionPatterns.map((p) => p.id),
        confidence: directionPatterns[0].confidence * 0.9, // Slightly lower confidence than the pattern itself
        suggestedActions: [
          `Allocate additional resources to support ${dominantType} evolution`,
          'Develop specialized metrics to track progress in this evolutionary direction',
          'Create targeted growth hooks aligned with this direction',
          'Document the evolutionary trajectory for system history',
        ],
        generatedAt: new Date(),
      });
    }

    // Insight 2: Evolution process effectiveness
    const processPatterns = patterns.filter(
      (p) =>
        p.description.includes('rate') || p.description.includes('acceptance')
    );

    if (processPatterns.length >= 1) {
      // Extract the acceptance rate from the pattern description
      const rateMatch =
        processPatterns[0].description.match(/rate:\s*([\d\.]+)%/);
      const acceptanceRate = rateMatch ? parseFloat(rateMatch[1]) : 50;

      insights.push({
        id: uuidv4(),
        title: 'Evolution Process Effectiveness',
        description: `The system's evolution proposal process is showing ${acceptanceRate > 70 ? 'high' : acceptanceRate > 40 ? 'moderate' : 'low'} effectiveness with an acceptance rate of ${acceptanceRate.toFixed(1)}%. This provides insights into the quality of proposals and the evaluation criteria being applied.`,
        category: 'system_evolution',
        relatedPatterns: processPatterns.map((p) => p.id),
        confidence: processPatterns[0].confidence * 0.9, // Slightly lower confidence than the pattern itself
        suggestedActions: [
          acceptanceRate < 50
            ? 'Review and refine proposal generation criteria'
            : 'Document successful proposal characteristics',
          'Analyze rejected proposals for common patterns',
          'Consider adjustments to the proposal evaluation process',
          'Develop feedback mechanisms for proposal quality improvement',
        ],
        generatedAt: new Date(),
      });
    }

    return insights;
  }

  /**
   * Generates insights from interaction patterns
   *
   * @param patterns Interaction patterns
   * @returns Generated insights
   */
  private async generateInteractionInsights(
    patterns: ObservedPattern[]
  ): Promise<ObserverInsight[]> {
    const insights: ObserverInsight[] = [];

    // Insight 1: User engagement pattern
    const userPatterns = patterns.filter(
      (p) =>
        p.description.includes('user') || p.description.includes('interaction')
    );

    if (userPatterns.length >= 1) {
      // Extract regularity from the pattern description
      const regularityMatch = userPatterns[0].description.match(
        /(high|moderate|low)\s+regularity/
      );
      const regularity = regularityMatch ? regularityMatch[1] : 'variable';

      insights.push({
        id: uuidv4(),
        title: 'User Engagement Pattern',
        description: `The system is experiencing ${regularity} regularity in user engagement patterns. This provides insights into usage patterns and can inform system responsiveness and resource allocation strategies.`,
        category: 'interaction_dynamic',
        relatedPatterns: userPatterns.map((p) => p.id),
        confidence: userPatterns[0].confidence * 0.9, // Slightly lower confidence than the pattern itself
        suggestedActions: [
          `Optimize system responsiveness for ${regularity} engagement patterns`,
          'Develop user engagement metrics to track changes over time',
          'Consider adaptive resource allocation based on usage patterns',
          'Analyze correlation between user engagement and system performance',
        ],
        generatedAt: new Date(),
      });
    }

    // Insight 2: Agent collaboration dynamics
    const agentPatterns = patterns.filter(
      (p) => p.description.includes('agent') || p.description.includes('debate')
    );

    if (agentPatterns.length >= 1) {
      // Extract outcome from the pattern description
      const outcomeMatch =
        agentPatterns[0].description.match(/outcome:\s*([\w]+)/);
      const outcome = outcomeMatch ? outcomeMatch[1] : 'variable';

      insights.push({
        id: uuidv4(),
        title: 'Agent Collaboration Dynamics',
        description: `The system's multi-agent collaboration is showing a pattern of ${outcome} outcomes in debates and discussions. This provides insights into agent interaction dynamics and decision-making processes.`,
        category: 'agent_behavior',
        relatedPatterns: agentPatterns.map((p) => p.id),
        confidence: agentPatterns[0].confidence * 0.9, // Slightly lower confidence than the pattern itself
        suggestedActions: [
          outcome === 'consensus'
            ? 'Leverage consensus-building for complex decision tasks'
            : outcome === 'disagreement'
              ? 'Develop protocols for productive disagreement resolution'
              : 'Analyze debate outcomes for decision quality correlation',
          'Develop metrics for tracking collaboration effectiveness',
          'Consider specialized roles in multi-agent discussions',
          'Explore correlation between debate outcomes and implementation success',
        ],
        generatedAt: new Date(),
      });
    }

    return insights;
  }

  /**
   * Generates insights from reflection patterns
   *
   * @param patterns Reflection patterns
   * @returns Generated insights
   */
  private async generateReflectionInsights(
    patterns: ObservedPattern[]
  ): Promise<ObserverInsight[]> {
    const insights: ObserverInsight[] = [];

    // Insight 1: System introspection focus
    const focusPatterns = patterns.filter(
      (p) =>
        p.description.includes('type') || p.description.includes('dominant')
    );

    if (focusPatterns.length >= 1) {
      // Extract the dominant reflection type from the pattern description
      const typeMatch = focusPatterns[0].description.match(/type:\s*([\w_]+)/);
      const reflectionType = typeMatch ? typeMatch[1] : 'unspecified';

      insights.push({
        id: uuidv4(),
        title: 'System Introspection Focus',
        description: `The system is showing a dominant focus on ${reflectionType.replace(/_/g, ' ').toLowerCase()} in its introspective activities. This suggests a specific area of system self-awareness that may be particularly active or important.`,
        category: 'system_evolution',
        relatedPatterns: focusPatterns.map((p) => p.id),
        confidence: focusPatterns[0].confidence * 0.9, // Slightly lower confidence than the pattern itself
        suggestedActions: [
          `Develop deeper analysis capabilities for ${reflectionType.replace(/_/g, ' ').toLowerCase()} reflections`,
          'Create metrics to track the impact of these reflections on system behavior',
          'Consider expanding reflection capabilities to related areas',
          'Document insights from this reflection focus for system history',
        ],
        generatedAt: new Date(),
      });
    }

    // Insight 2: Temporal activity patterns
    const temporalPatterns = patterns.filter(
      (p) =>
        p.description.includes('temporal') ||
        p.description.includes('hour') ||
        p.description.includes('time')
    );

    if (temporalPatterns.length >= 1) {
      // Extract the peak hour from the pattern description
      const hourMatch = temporalPatterns[0].description.match(/hour\s*(\d+)/);
      const peakHour = hourMatch ? parseInt(hourMatch[1]) : 0;

      insights.push({
        id: uuidv4(),
        title: 'System Activity Temporal Pattern',
        description: `The system shows a distinct temporal pattern with peak activity during hour ${peakHour}. This temporal pattern may correlate with specific system processes, user interaction patterns, or external factors.`,
        category: 'system_evolution',
        relatedPatterns: temporalPatterns.map((p) => p.id),
        confidence: temporalPatterns[0].confidence * 0.9, // Slightly lower confidence than the pattern itself
        suggestedActions: [
          `Analyze correlation between hour ${peakHour} activity and system performance`,
          'Consider resource optimization based on temporal patterns',
          'Develop adaptive scheduling for system maintenance activities',
          'Monitor for changes in temporal patterns over time',
        ],
        generatedAt: new Date(),
      });
    }

    return insights;
  }

  /**
   * Generates insights that span multiple pattern types
   *
   * @param patternsByType Patterns grouped by type
   * @returns Generated insights
   */
  private async generateCrossPatternInsights(
    patternsByType: Record<string, ObservedPattern[]>
  ): Promise<ObserverInsight[]> {
    const insights: ObserverInsight[] = [];

    // Insight 1: Consolidation-Evolution Connection
    if (patternsByType['consolidation'] && patternsByType['evolution']) {
      const consolidationPatterns = patternsByType['consolidation'];
      const evolutionPatterns = patternsByType['evolution'];

      // Look for emotional patterns in consolidation
      const emotionalPatterns = consolidationPatterns.filter(
        (p) =>
          p.description.includes('emotional') ||
          p.description.includes('resonance')
      );

      // Look for evolution direction patterns
      const directionPatterns = evolutionPatterns.filter(
        (p) =>
          p.description.includes('type') || p.description.includes('dominant')
      );

      if (emotionalPatterns.length > 0 && directionPatterns.length > 0) {
        insights.push({
          id: uuidv4(),
          title: 'Emotion-Driven Evolution Pathway',
          description:
            'The system appears to be developing an evolution pathway driven by emotional intelligence. High emotional resonance in memory consolidation correlates with specific evolution proposal patterns, suggesting that emotional understanding is guiding system growth.',
          category: 'system_evolution',
          relatedPatterns: [
            ...emotionalPatterns.map((p) => p.id),
            ...directionPatterns.map((p) => p.id),
          ],
          confidence: Math.min(
            0.7,
            (emotionalPatterns[0].confidence +
              directionPatterns[0].confidence) /
              2
          ),
          suggestedActions: [
            'Develop explicit emotion-driven evolution strategies',
            'Create metrics to track correlation between emotional resonance and evolution success',
            'Consider specialized SoulFrame roles for emotional intelligence development',
            'Document the emotion-driven evolution pathway for system history',
          ],
          generatedAt: new Date(),
        });
      }
    }

    // Insight 2: Interaction-Reflection Connection
    if (patternsByType['interaction'] && patternsByType['reflection']) {
      const interactionPatterns = patternsByType['interaction'];
      const reflectionPatterns = patternsByType['reflection'];

      // Look for user interaction patterns
      const userPatterns = interactionPatterns.filter(
        (p) =>
          p.description.includes('user') ||
          p.description.includes('interaction')
      );

      // Look for temporal reflection patterns
      const temporalPatterns = reflectionPatterns.filter(
        (p) =>
          p.description.includes('temporal') ||
          p.description.includes('hour') ||
          p.description.includes('time')
      );

      if (userPatterns.length > 0 && temporalPatterns.length > 0) {
        insights.push({
          id: uuidv4(),
          title: 'User-Driven System Reflection Cycle',
          description:
            'The system appears to have developed a reflection cycle that correlates with user interaction patterns. This suggests that user engagement is triggering system introspection, potentially creating a feedback loop for adaptive behavior.',
          category: 'interaction_dynamic',
          relatedPatterns: [
            ...userPatterns.map((p) => p.id),
            ...temporalPatterns.map((p) => p.id),
          ],
          confidence: Math.min(
            0.7,
            (userPatterns[0].confidence + temporalPatterns[0].confidence) / 2
          ),
          suggestedActions: [
            'Analyze the temporal relationship between user interactions and system reflections',
            'Develop metrics to track the impact of user engagement on system introspection',
            'Consider explicit user-triggered reflection mechanisms',
            'Explore ways to optimize the user-reflection feedback loop',
          ],
          generatedAt: new Date(),
        });
      }
    }

    return insights;
  }

  /**
   * Generates evolution proposals from insights
   *
   * @param insights Insights to generate proposals from
   * @returns Generated proposals
   */
  private async generateEvolutionProposals(
    insights: ObserverInsight[]
  ): Promise<EvolutionProposal[]> {
    const proposals: EvolutionProposal[] = [];

    // Get all SoulFrames to include in proposals
    const soulFrames = await this.soulFrameManager.getAllSoulFrames();
    if (soulFrames.length === 0) {
      return proposals;
    }

    // Create a SoulWeaving session for the proposals
    const session = await this.soulWeaverProtocol.initiateSoulWeavingSession(
      soulFrames.map((sf) => sf.identity.id),
      'Observer-generated evolution proposals'
    );

    // Generate proposals for high-confidence insights
    for (const insight of insights.filter((i) => i.confidence >= 0.8)) {
      // Determine proposal type based on insight category
      let proposalType:
        | 'structural'
        | 'behavioral'
        | 'cognitive'
        | 'relational' = 'cognitive';

      switch (insight.category) {
        case 'system_evolution':
          proposalType = 'structural';
          break;

        case 'agent_behavior':
          proposalType = 'behavioral';
          break;

        case 'memory_pattern':
          proposalType = 'cognitive';
          break;

        case 'interaction_dynamic':
          proposalType = 'relational';
          break;
      }

      // Create mock consolidation results based on the insight
      const mockResults: CODESIGConsolidationResult[] = soulFrames.map(
        (sf) => ({
          summary: insight.title,
          emotionalResonance: insight.confidence,
          intentAlignment: insight.confidence,
          soulFrameId: sf.identity.id,
          codalogueEntryId: insight.id,
        })
      );

      // Generate the proposal
      const proposal = await this.soulWeaverProtocol.generateEvolutionProposal(
        session.id,
        mockResults,
        proposalType
      );

      proposals.push(proposal);

      // Log the proposal generation
      await this.codalogueProtocolLedger.recordSystemReflection({
        reflectionType: 'OBSERVER_GENERATED_PROPOSAL',
        content: `Observer Agent generated evolution proposal: ${proposal.title}`,
        metadata: {
          proposalId: proposal.id,
          insightId: insight.id,
          proposalType,
          confidence: insight.confidence,
        },
      });
    }

    return proposals;
  }

  /**
   * Gets all detected patterns
   *
   * @param minConfidence Minimum confidence threshold
   * @returns All detected patterns above the confidence threshold
   */
  getAllPatterns(minConfidence: number = 0): ObservedPattern[] {
    return Array.from(this.patterns.values())
      .filter((pattern) => pattern.confidence >= minConfidence)
      .sort((a, b) => b.confidence - a.confidence);
  }

  /**
   * Gets patterns of a specific type
   *
   * @param patternType Type of patterns to get
   * @param minConfidence Minimum confidence threshold
   * @returns Patterns of the specified type above the confidence threshold
   */
  getPatternsByType(
    patternType: 'consolidation' | 'evolution' | 'interaction' | 'reflection',
    minConfidence: number = 0
  ): ObservedPattern[] {
    return Array.from(this.patterns.values())
      .filter(
        (pattern) =>
          pattern.patternType === patternType &&
          pattern.confidence >= minConfidence
      )
      .sort((a, b) => b.confidence - a.confidence);
  }

  /**
   * Gets all generated insights
   *
   * @param minConfidence Minimum confidence threshold
   * @returns All generated insights above the confidence threshold
   */
  getAllInsights(minConfidence: number = 0): ObserverInsight[] {
    return Array.from(this.insights.values())
      .filter((insight) => insight.confidence >= minConfidence)
      .sort((a, b) => b.confidence - a.confidence);
  }

  /**
   * Gets insights of a specific category
   *
   * @param category Category of insights to get
   * @param minConfidence Minimum confidence threshold
   * @returns Insights of the specified category above the confidence threshold
   */
  getInsightsByCategory(
    category:
      | 'system_evolution'
      | 'agent_behavior'
      | 'memory_pattern'
      | 'interaction_dynamic',
    minConfidence: number = 0
  ): ObserverInsight[] {
    return Array.from(this.insights.values())
      .filter(
        (insight) =>
          insight.category === category && insight.confidence >= minConfidence
      )
      .sort((a, b) => b.confidence - a.confidence);
  }
}
